config PARTITION_TABLE_OFFSET
    hex
    default 0x8000

menu "Bootloader config"


    choice BOOTLOADER_COMPILER_OPTIMIZATION
        prompt "Bootloader optimization Level"
        default BOOTLOADER_COMPILER_OPTIMIZATION_SIZE
        help
            This option sets compiler optimization level (gcc -O argument)
            for the bootloader.

            - The default "Size" setting will add the -0s flag to CFLAGS.
            - The "Debug" setting will add the -Og flag to CFLAGS.
            - The "Performance" setting will add the -O2 flag to CFLAGS.
            - The "None" setting will add the -O0 flag to CFLAGS.

            Note that custom optimization levels may be unsupported.

        config BOOTLOADER_COMPILER_OPTIMIZATION_SIZE
            bool "Size (-Os)"
        config BOOTLOADER_COMPILER_OPTIMIZATION_DEBUG
            bool "Debug (-Og)"
        config BOOTLOADER_COMPILER_OPTIMIZATION_PERF
            bool "Optimize for performance (-O2)"
        config BOOTLOADER_COMPILER_OPTIMIZATION_NONE
            bool "Debug without optimization (-O0)"
    endchoice

    choice BOOTLOADER_LOG_LEVEL
        bool "Bootloader log verbosity"
        default BOOTLOADER_LOG_LEVEL_INFO
        help
            Specify how much output to see in bootloader logs.

        config BOOTLOADER_LOG_LEVEL_NONE
            bool "No output"
        config BOOTLOADER_LOG_LEVEL_ERROR
            bool "Error"
        config BOOTLOADER_LOG_LEVEL_WARN
            bool "Warning"
        config BOOTLOADER_LOG_LEVEL_INFO
            bool "Info"
        config BOOTLOADER_LOG_LEVEL_DEBUG
            bool "Debug"
        config BOOTLOADER_LOG_LEVEL_VERBOSE
            bool "Verbose"
    endchoice

    config BOOTLOADER_LOG_LEVEL
        int
        default 0 if BOOTLOADER_LOG_LEVEL_NONE
        default 1 if BOOTLOADER_LOG_LEVEL_ERROR
        default 2 if BOOTLOADER_LOG_LEVEL_WARN
        default 3 if BOOTLOADER_LOG_LEVEL_INFO
        default 4 if BOOTLOADER_LOG_LEVEL_DEBUG
        default 5 if BOOTLOADER_LOG_LEVEL_VERBOSE

    config BOOTLOADER_SPI_CUSTOM_WP_PIN
        bool "Use custom SPI Flash WP Pin when flash pins set in eFuse (read help)"
        depends on IDF_TARGET_ESP32 && (ESPTOOLPY_FLASHMODE_QIO || ESPTOOLPY_FLASHMODE_QOUT)
        default y if BOOTLOADER_SPI_WP_PIN != 7  # backwards compatibility, can remove in IDF 5
        default n
        help
            This setting is only used if the SPI flash pins have been overridden by setting the eFuses
            SPI_PAD_CONFIG_xxx, and the SPI flash mode is QIO or QOUT.

            When this is the case, the eFuse config only defines 3 of the 4 Quad I/O data pins. The WP pin (aka
            ESP32 pin "SD_DATA_3" or SPI flash pin "IO2") is not specified in eFuse. The same pin is also used
            for external SPIRAM if it is enabled.

            If this config item is set to N (default), the correct WP pin will be automatically used for any
            Espressif chip or module with integrated flash. If a custom setting is needed, set this config item to
            Y and specify the GPIO number connected to the WP.

    config BOOTLOADER_SPI_WP_PIN
        int "Custom SPI Flash WP Pin"
        range 0 33
        default 7
        depends on IDF_TARGET_ESP32 && (ESPTOOLPY_FLASHMODE_QIO || ESPTOOLPY_FLASHMODE_QOUT)
        #depends on BOOTLOADER_SPI_CUSTOM_WP_PIN  # backwards compatibility, can uncomment in IDF 5
        help
            The option "Use custom SPI Flash WP Pin" must be set or this value is ignored

            If burning a customized set of SPI flash pins in eFuse and using QIO or QOUT mode for flash, set this
            value to the GPIO number of the SPI flash WP pin.

    choice BOOTLOADER_VDDSDIO_BOOST
        bool "VDDSDIO LDO voltage"
        default BOOTLOADER_VDDSDIO_BOOST_1_9V
        help
            If this option is enabled, and VDDSDIO LDO is set to 1.8V (using eFuse
            or MTDI bootstrapping pin), bootloader will change LDO settings to
            output 1.9V instead. This helps prevent flash chip from browning out
            during flash programming operations.

            This option has no effect if VDDSDIO is set to 3.3V, or if the internal
            VDDSDIO regulator is disabled via eFuse.

        config BOOTLOADER_VDDSDIO_BOOST_1_8V
            bool "1.8V"
            depends on !ESPTOOLPY_FLASHFREQ_80M
        config BOOTLOADER_VDDSDIO_BOOST_1_9V
            bool "1.9V"
    endchoice

    config BOOTLOADER_FACTORY_RESET
        bool "GPIO triggers factory reset"
        default N
        help
            Allows to reset the device to factory settings:
            - clear one or more data partitions;
            - boot from "factory" partition.
            The factory reset will occur if there is a GPIO input held at the configured level while
            device starts up. See settings below.

    config BOOTLOADER_NUM_PIN_FACTORY_RESET
        int "Number of the GPIO input for factory reset"
        depends on BOOTLOADER_FACTORY_RESET
        range 0 39 if IDF_TARGET_ESP32
        range 0 44 if IDF_TARGET_ESP32S2
        default 4
        help
            The selected GPIO will be configured as an input with internal pull-up enabled (note that on some SoCs.
            not all pins have an internal pull-up, consult the hardware datasheet for details.) To trigger a factory
            reset, this GPIO must be held high or low (as configured) on startup.

    choice BOOTLOADER_FACTORY_RESET_PIN_LEVEL
        bool "Factory reset GPIO level"
        depends on BOOTLOADER_FACTORY_RESET
        default BOOTLOADER_FACTORY_RESET_PIN_LOW
        help
            Pin level for factory reset, can be triggered on low or high.

        config BOOTLOADER_FACTORY_RESET_PIN_LOW
            bool "Reset on GPIO low"

        config BOOTLOADER_FACTORY_RESET_PIN_HIGH
            bool "Reset on GPIO high"
    endchoice

    config BOOTLOADER_OTA_DATA_ERASE
        bool "Clear OTA data on factory reset (select factory partition)"
        depends on BOOTLOADER_FACTORY_RESET
        help
            The device will boot from "factory" partition (or OTA slot 0 if no factory partition is present) after a
            factory reset.

    config BOOTLOADER_DATA_FACTORY_RESET
        string "Comma-separated names of partitions to clear on factory reset"
        depends on BOOTLOADER_FACTORY_RESET
        default "nvs"
        help
            Allows customers to select which data partitions will be erased while factory reset.

            Specify the names of partitions as a comma-delimited with optional spaces for readability. (Like this:
            "nvs, phy_init, ...")
            Make sure that the name specified in the partition table and here are the same.
            Partitions of type "app" cannot be specified here.

    config BOOTLOADER_APP_TEST
        bool "GPIO triggers boot from test app partition"
        default N
        depends on !BOOTLOADER_APP_ANTI_ROLLBACK
        help
            Allows to run the test app from "TEST" partition.
            A boot from "test" partition will occur if there is a GPIO input pulled low while device starts up.
            See settings below.

    config BOOTLOADER_NUM_PIN_APP_TEST
        int "Number of the GPIO input to boot TEST partition"
        depends on BOOTLOADER_APP_TEST
        range 0 39
        default 18
        help
            The selected GPIO will be configured as an input with internal pull-up enabled.
            To trigger a test app, this GPIO must be pulled low on reset.
            After the GPIO input is deactivated and the device reboots, the old application will boot.
            (factory or OTA[x]).
            Note that GPIO34-39 do not have an internal pullup and an external one must be provided.

    choice BOOTLOADER_APP_TEST_PIN_LEVEL
        bool "App test GPIO level"
        depends on BOOTLOADER_APP_TEST
        default BOOTLOADER_APP_TEST_PIN_LOW
        help
            Pin level for app test, can be triggered on low or high.

        config BOOTLOADER_APP_TEST_PIN_LOW
            bool "Enter test app on GPIO low"

        config BOOTLOADER_APP_TEST_PIN_HIGH
            bool "Enter test app on GPIO high"
    endchoice

    config BOOTLOADER_HOLD_TIME_GPIO
        int "Hold time of GPIO for reset/test mode (seconds)"
        depends on BOOTLOADER_FACTORY_RESET || BOOTLOADER_APP_TEST
        default 5
        help
            The GPIO must be held low continuously for this period of time after reset
            before a factory reset or test partition boot (as applicable) is performed.

    config BOOTLOADER_REGION_PROTECTION_ENABLE
        bool "Enable protection for unmapped memory regions"
        default y
        help
            Protects the unmapped memory regions of the entire address space from unintended accesses.
            This will ensure that an exception will be triggered whenever the CPU performs a memory
            operation on unmapped regions of the address space.

    config BOOTLOADER_WDT_ENABLE
        bool "Use RTC watchdog in start code"
        default y
        help
            Tracks the execution time of startup code.
            If the execution time is exceeded, the RTC_WDT will restart system.
            It is also useful to prevent a lock up in start code caused by an unstable power source.
            NOTE: Tracks the execution time starts from the bootloader code - re-set timeout, while selecting the
            source for slow_clk - and ends calling app_main.
            Re-set timeout is needed due to WDT uses a SLOW_CLK clock source. After changing a frequency slow_clk a
            time of WDT needs to re-set for new frequency.
            slow_clk depends on RTC_CLK_SRC (INTERNAL_RC or EXTERNAL_CRYSTAL).

    config BOOTLOADER_WDT_DISABLE_IN_USER_CODE
        bool "Allows RTC watchdog disable in user code"
        depends on BOOTLOADER_WDT_ENABLE
        default n
        help
            If this option is set, the ESP-IDF app must explicitly reset, feed, or disable the rtc_wdt in
            the app's own code.
            If this option is not set (default), then rtc_wdt will be disabled by ESP-IDF before calling
            the app_main() function.

            Use function rtc_wdt_feed() for resetting counter of rtc_wdt.
            Use function rtc_wdt_disable() for disabling rtc_wdt.

    config BOOTLOADER_WDT_TIME_MS
        int "Timeout for RTC watchdog (ms)"
        depends on BOOTLOADER_WDT_ENABLE
        default 9000
        range 0 120000
        help
            Verify that this parameter is correct and more then the execution time.
            Pay attention to options such as reset to factory, trigger test partition and encryption on boot
            - these options can increase the execution time.
            Note: RTC_WDT will reset while encryption operations will be performed.

    config BOOTLOADER_APP_ROLLBACK_ENABLE
        bool "Enable app rollback support"
        default n
        help
            After updating the app, the bootloader runs a new app with the "ESP_OTA_IMG_PENDING_VERIFY" state set.
            This state prevents the re-run of this app. After the first boot of the new app in the user code, the
            function should be called to confirm the operability of the app or vice versa about its non-operability.
            If the app is working, then it is marked as valid. Otherwise, it is marked as not valid and rolls back to
            the previous working app. A reboot is performed, and the app is booted before the software update.
            Note: If during the first boot a new app the power goes out or the WDT works, then roll back will happen.
            Rollback is possible only between the apps with the same security versions.

    config BOOTLOADER_APP_ANTI_ROLLBACK
        bool "Enable app anti-rollback support"
        depends on BOOTLOADER_APP_ROLLBACK_ENABLE
        default n
        help
            This option prevents rollback to previous firmware/application image with lower security version.

    config BOOTLOADER_APP_SECURE_VERSION
        int "eFuse secure version of app"
        depends on BOOTLOADER_APP_ANTI_ROLLBACK
        default 0
        help
            The secure version is the sequence number stored in the header of each firmware.
            The security version is set in the bootloader, version is recorded in the eFuse field
            as the number of set ones. The allocated number of bits in the efuse field
            for storing the security version is limited (see BOOTLOADER_APP_SEC_VER_SIZE_EFUSE_FIELD option).

            Bootloader: When bootloader selects an app to boot, an app is selected that has
            a security version greater or equal that recorded in eFuse field.
            The app is booted with a higher (or equal) secure version.

            The security version is worth increasing if in previous versions there is
            a significant vulnerability and their use is not acceptable.

            Your partition table should has a scheme with ota_0 + ota_1 (without factory).

    config BOOTLOADER_APP_SEC_VER_SIZE_EFUSE_FIELD
        int "Size of the efuse secure version field"
        depends on BOOTLOADER_APP_ANTI_ROLLBACK
        range 1 32 if IDF_TARGET_ESP32
        default 32 if IDF_TARGET_ESP32
        range 1 4 if IDF_TARGET_ESP32C2
        default 4 if IDF_TARGET_ESP32C2
        range 1 16
        default 16
        help
            The size of the efuse secure version field.
            Its length is limited to 32 bits for ESP32 and 16 bits for ESP32-S2.
            This determines how many times the security version can be increased.

    config BOOTLOADER_EFUSE_SECURE_VERSION_EMULATE
        bool "Emulate operations with efuse secure version(only test)"
        default n
        depends on BOOTLOADER_APP_ANTI_ROLLBACK
        select EFUSE_VIRTUAL
        select EFUSE_VIRTUAL_KEEP_IN_FLASH
        help
            This option allows to emulate read/write operations with all eFuses and efuse secure version.
            It allows to test anti-rollback implemention without permanent write eFuse bits.
            There should be an entry in partition table with following details: `emul_efuse, data, efuse, , 0x2000`.

            This option enables: EFUSE_VIRTUAL and EFUSE_VIRTUAL_KEEP_IN_FLASH.

    config BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP
        bool "Skip image validation when exiting deep sleep"
        # note: dependencies for this config item are different to other "skip image validation"
        # options, allowing to turn on "allow insecure options" and have secure boot with
        # "skip validation when existing deep sleep". Keeping this to avoid a breaking change,
        # but - as noted in help - it invalidates the integrity of Secure Boot checks
        depends on SOC_RTC_FAST_MEM_SUPPORTED && ((SECURE_BOOT && SECURE_BOOT_INSECURE) || !SECURE_BOOT)
        default n
        help
            This option disables the normal validation of an image coming out of
            deep sleep (checksums, SHA256, and signature). This is a trade-off
            between wakeup performance from deep sleep, and image integrity checks.

            Only enable this if you know what you are doing. It should not be used
            in conjunction with using deep_sleep() entry and changing the active OTA
            partition as this would skip the validation upon first load of the new
            OTA partition.

            It is possible to enable this option with Secure Boot if "allow insecure
            options" is enabled, however it's strongly recommended to NOT enable it as
            it may allow a Secure Boot bypass.

    config BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON
        bool "Skip image validation from power on reset (READ HELP FIRST)"
        # only available if both Secure Boot and Check Signature on Boot are disabled
        depends on !SECURE_SIGNED_ON_BOOT
        default n
        help
            Some applications need to boot very quickly from power on. By default, the entire app binary
            is read from flash and verified which takes up a significant portion of the boot time.

            Enabling this option will skip validation of the app when the SoC boots from power on.
            Note that in this case it's not possible for the bootloader to detect if an app image is
            corrupted in the flash, therefore it's not possible to safely fall back to a different app
            partition. Flash corruption of this kind is unlikely but can happen if there is a serious
            firmware bug or physical damage.

            Following other reset types, the bootloader will still validate the app image. This increases
            the chances that flash corruption resulting in a crash can be detected following soft reset, and
            the bootloader will fall back to a valid app image. To increase the chances of successfully recovering
            from a flash corruption event, keep the option BOOTLOADER_WDT_ENABLE enabled and consider also enabling
            BOOTLOADER_WDT_DISABLE_IN_USER_CODE - then manually disable the RTC Watchdog once the app is running.
            In addition, enable both the Task and Interrupt watchdog timers with reset options set.

    config BOOTLOADER_SKIP_VALIDATE_ALWAYS
        bool "Skip image validation always (READ HELP FIRST)"
        # only available if both Secure Boot and Check Signature on Boot are disabled
        depends on !SECURE_SIGNED_ON_BOOT
        default n
        select BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP if SOC_RTC_FAST_MEM_SUPPORTED
        select BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON
        help
            Selecting this option prevents the bootloader from ever validating the app image before
            booting it. Any flash corruption of the selected app partition will make the entire SoC
            unbootable.

            Although flash corruption is a very rare case, it is not recommended to select this option.
            Consider selecting "Skip image validation from power on reset" instead. However, if boot time
            is the only important factor then it can be enabled.

    config BOOTLOADER_RESERVE_RTC_SIZE
        hex
        depends on SOC_RTC_FAST_MEM_SUPPORTED
        default 0x10 if BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP || BOOTLOADER_CUSTOM_RESERVE_RTC
        default 0
        help
            Reserve RTC FAST memory for Skip image validation. This option in bytes.
            This option reserves an area in the RTC FAST memory (access only PRO_CPU).
            Used to save the addresses of the selected application.
            When a wakeup occurs (from Deep sleep), the bootloader retrieves it and
            loads the application without validation.

    config BOOTLOADER_CUSTOM_RESERVE_RTC
        bool "Reserve RTC FAST memory for custom purposes"
        depends on SOC_RTC_FAST_MEM_SUPPORTED
        default n
        help
            This option allows the customer to place data in the RTC FAST memory,
            this area remains valid when rebooted, except for power loss.
            This memory is located at a fixed address and is available
            for both the bootloader and the application.
            (The application and bootoloader must be compiled with the same option).
            The RTC FAST memory has access only through PRO_CPU.

    config BOOTLOADER_CUSTOM_RESERVE_RTC_SIZE
        hex "Size in bytes for custom purposes"
        default 0
        depends on BOOTLOADER_CUSTOM_RESERVE_RTC
        help
            This option reserves in RTC FAST memory the area for custom purposes.
            If you want to create your own bootloader and save more information
            in this area of memory, you can increase it. It must be a multiple of 4 bytes.
            This area (rtc_retain_mem_t) is reserved and has access from the bootloader and an application.

    config BOOTLOADER_FLASH_XMC_SUPPORT
        bool "Enable the support for flash chips of XMC (READ HELP FIRST)"
        default y
        help
            Perform the startup flow recommended by XMC. Please consult XMC for the details of this flow.
            XMC chips will be forbidden to be used, when this option is disabled.

            DON'T DISABLE THIS UNLESS YOU KNOW WHAT YOU ARE DOING.

endmenu  # Bootloader

