config ESP_SYSTEM_SINGLE_CORE_MODE
    bool
    default n
config ESP_SYSTEM_RTC_EXT_XTAL
    # This is a High Layer Kconfig option, invisible, can be selected by other Kconfig option
    # e.g. It will be selected on when RTC_CLK_SRC_EXT_CRYS is on
    bool
    default n

config ESP_SYSTEM_RTC_EXT_OSC
    # This is a High Layer Kconfig option, invisible, can be selected by other Kconfig option
    # e.g. It will be selected on when ESPX_RTC_CLK_SRC_EXT_OSC is on
    bool
    default n

# vfs related
config VFS_SUPPORT_IO
    bool
    default y
config VFS_SUPPORT_DIR
    bool
    default y
config VFS_SUPPORT_SELECT
    bool
    default y
config VFS_SUPPRESS_SELECT_DEBUG_OUTPUT
    bool
    default y
config VFS_SUPPORT_TERMIOS
    bool
    default y
config VFS_SEMIHOSTFS_MAX_MOUNT_POINTS
    # do not how
    int
    default 1

menu "ESP System Settings"
    rsource "driver/$IDF_TARGET/Kconfig.cpu"
    orsource "driver/$IDF_TARGET/Kconfig.cache"

    choice ESP_SYSTEM_PANIC
        prompt "Panic handler behaviour"
        default ESP_SYSTEM_PANIC_PRINT_REBOOT
        help
            If FreeRTOS detects unexpected behaviour or an unhandled exception, the panic handler is
            invoked. Configure the panic handler's action here.

        config ESP_SYSTEM_PANIC_PRINT_HALT
            bool "Print registers and halt"
            help
                Outputs the relevant registers over the serial port and halt the
                processor. Needs a manual reset to restart.

        config ESP_SYSTEM_PANIC_PRINT_REBOOT
            bool "Print registers and reboot"
            help
                Outputs the relevant registers over the serial port and immediately
                reset the processor.

        config ESP_SYSTEM_PANIC_SILENT_REBOOT
            bool "Silent reboot"
            help
                Just resets the processor without outputting anything

        config ESP_SYSTEM_PANIC_GDBSTUB
            bool "GDBStub on panic"
            select ESP_GDBSTUB_ENABLED
            help
                Invoke gdbstub on the serial port, allowing for gdb to attach to it to do a postmortem
                of the crash.

        config ESP_SYSTEM_GDBSTUB_RUNTIME
            bool "GDBStub at runtime"
            select ESP_GDBSTUB_ENABLED
            depends on !IDF_TARGET_ESP32C2
            help
                Invoke gdbstub on the serial port, allowing for gdb to attach to it and to do a debug on runtime.
    endchoice

    config ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS
        int "Panic reboot delay (Seconds)"
        default 0
        range 0 99
        depends on ESP_SYSTEM_PANIC_PRINT_REBOOT
        help
            After the panic handler executes, you can specify a number of seconds to
            wait before the device reboots.

    config ESP_SYSTEM_RTC_EXT_XTAL_BOOTSTRAP_CYCLES
        int "Bootstrap cycles for external 32kHz crystal"
        depends on ESP_SYSTEM_RTC_EXT_XTAL
        default 5 if IDF_TARGET_ESP32
        default 0
        range 0 32768
        help
            To reduce the startup time of an external RTC crystal,
            we bootstrap it with a 32kHz square wave for a fixed number of cycles.
            Setting 0 will disable bootstrapping (if disabled, the crystal may take
            longer to start up or fail to oscillate under some conditions).

            If this value is too high, a faulty crystal may initially start and then fail.
            If this value is too low, an otherwise good crystal may not start.

            To accurately determine if the crystal has started,
            set a larger "Number of cycles for RTC_SLOW_CLK calibration" (about 3000).

    config ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK
        bool
        default y if IDF_TARGET_ESP32 && FREERTOS_UNICORE
        default y if IDF_TARGET_ESP32S2
        default y if IDF_TARGET_ESP32C3
        default y if IDF_TARGET_ESP32S3
        default y if IDF_TARGET_ESP32H4
        default y if IDF_TARGET_ESP32C6
        default y if IDF_TARGET_ESP32H2
        depends on !IDF_TARGET_ESP32C2

    config ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP
        bool "Enable RTC fast memory for dynamic allocations"
        default y
        depends on ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK
        help
            This config option allows to add RTC fast memory region to system heap with capability
            similar to that of DRAM region but without DMA. This memory will be consumed first per
            heap initialization order by early startup services and scheduler related code. Speed
            wise RTC fast memory operates on APB clock and hence does not have much performance impact.

    config ESP_SYSTEM_USE_EH_FRAME
        bool "Generate and use eh_frame for backtracing"
        default n
        depends on IDF_TARGET_ARCH_RISCV
        help
            Generate DWARF information for each function of the project. These information will parsed and used to
            perform backtracing when panics occur. Activating this option will activate asynchronous frame unwinding
            and generation of both .eh_frame and .eh_frame_hdr sections, resulting in a bigger binary size (20% to
            100% larger). The main purpose of this option is to be able to have a backtrace parsed and printed by
            the program itself, regardless of the serial monitor used.
            This option shall NOT be used for production.

    menu "Memory protection"
        config ESP_SYSTEM_PMP_IDRAM_SPLIT
            bool "Enable IRAM/DRAM split protection"
            depends on SOC_CPU_IDRAM_SPLIT_USING_PMP
            default "y"
            help
                If enabled, the CPU watches all the memory access and raises an exception in case
                of any memory violation. This feature automatically splits
                the SRAM memory, using PMP, into data and instruction segments and sets Read/Execute permissions
                for the instruction part (below given splitting address) and Read/Write permissions
                for the data part (above the splitting address). The memory protection is effective
                on all access through the IRAM0 and DRAM0 buses.

        config ESP_SYSTEM_MEMPROT_FEATURE
            bool "Enable memory protection"
            depends on SOC_MEMPROT_SUPPORTED
            default "y"
            help
                If enabled, the permission control module watches all the memory access and fires the panic handler
                if a permission violation is detected. This feature automatically splits
                the SRAM memory into data and instruction segments and sets Read/Execute permissions
                for the instruction part (below given splitting address) and Read/Write permissions
                for the data part (above the splitting address). The memory protection is effective
                on all access through the IRAM0 and DRAM0 buses.

        config ESP_SYSTEM_MEMPROT_FEATURE_LOCK
            depends on ESP_SYSTEM_MEMPROT_FEATURE
            bool "Lock memory protection settings"
            default "y"
            help
                Once locked, memory protection settings cannot be changed anymore.
                The lock is reset only on the chip startup.
    endmenu

    config ESP_SYSTEM_EVENT_QUEUE_SIZE
        int "System event queue size"
        default 32
        help
            Config system event queue size in different application.

    config ESP_SYSTEM_EVENT_TASK_STACK_SIZE
        int "Event loop task stack size"
        default 2304
        help
            Config system event task stack size in different application.

    config ESP_MAIN_TASK_STACK_SIZE
        int "Main task stack size"
        default 3584
        help
            Configure the "main task" stack size. This is the stack of the task
            which calls app_main(). If app_main() returns then this task is deleted
            and its stack memory is freed.

    choice ESP_MAIN_TASK_AFFINITY
        prompt "Main task core affinity"
        default ESP_MAIN_TASK_AFFINITY_NO_AFFINITY
        help
            Configure the "main task" core affinity. This is the used core of the task
            which calls app_main(). If app_main() returns then this task is deleted.

        config ESP_MAIN_TASK_AFFINITY_CPU0
            bool "CPU0"
        config ESP_MAIN_TASK_AFFINITY_CPU1
            bool "CPU1"
            depends on !FREERTOS_UNICORE
        config ESP_MAIN_TASK_AFFINITY_NO_AFFINITY
            bool "No affinity"
    endchoice

    config ESP_MAIN_TASK_AFFINITY
        hex
        default 0x0 if ESP_MAIN_TASK_AFFINITY_CPU0
        default 0x1 if ESP_MAIN_TASK_AFFINITY_CPU1
        default FREERTOS_NO_AFFINITY if ESP_MAIN_TASK_AFFINITY_NO_AFFINITY

    config ESP_MINIMAL_SHARED_STACK_SIZE
        int "Minimal allowed size for shared stack"
        default 2048
        help
            Minimal value of size, in bytes, accepted to execute a expression
            with shared stack.

    config ESP_PANIC_HANDLER_IRAM
        bool "Place panic handler code in IRAM"
        default n
        help
            If this option is disabled (default), the panic handler code is placed in flash not IRAM.
            This means that if ESP-IDF crashes while flash cache is disabled, the panic handler will
            automatically re-enable flash cache before running GDB Stub or Core Dump. This adds some minor
            risk, if the flash cache status is also corrupted during the crash.

            If this option is enabled, the panic handler code (including required UART functions) is placed
            in IRAM. This may be necessary to debug some complex issues with crashes while flash cache is
            disabled (for example, when writing to SPI flash) or when flash cache is corrupted when an exception
            is triggered.

    config ESP_DEBUG_STUBS_ENABLE
        bool "OpenOCD debug stubs"
        default COMPILER_OPTIMIZATION_LEVEL_DEBUG
        depends on !ESP32_TRAX && !ESP32S2_TRAX && !ESP32S3_TRAX
        help
            Debug stubs are used by OpenOCD to execute pre-compiled onboard code
            which does some useful debugging stuff, e.g. GCOV data dump.

    config ESP_DEBUG_OCDAWARE
        bool "Make exception and panic handlers JTAG/OCD aware"
        default y
        select FREERTOS_DEBUG_OCDAWARE
        help
            The FreeRTOS panic and unhandled exception handers can detect a JTAG OCD debugger and
            instead of panicking, have the debugger stop on the offending instruction.

    choice ESP_SYSTEM_CHECK_INT_LEVEL
        prompt "Interrupt level to use for Interrupt Watchdog and other system checks"
        default ESP_SYSTEM_CHECK_INT_LEVEL_4
        help
            Interrupt level to use for Interrupt Watchdog and other system checks.

        config ESP_SYSTEM_CHECK_INT_LEVEL_5
            bool "Level 5 interrupt"
            depends on IDF_TARGET_ESP32
            help
                Using level 5 interrupt for Interrupt Watchdog and other system checks.

        config ESP_SYSTEM_CHECK_INT_LEVEL_4
            bool "Level 4 interrupt"
            depends on !BTDM_CTRL_HLI
            help
                Using level 4 interrupt for Interrupt Watchdog and other system checks.
    endchoice

    # Insert chip-specific system config
    rsource "$IDF_PATH/components/esp_system/port/soc/$IDF_TARGET/Kconfig.system"

    config ESP_SYSTEM_BROWNOUT_INTR
        bool
        default n
        help
            This config allows to trigger an interrupt when brownout detected. Software restart will be done
            at the end of the default callback.
            Two occasions need to restart the chip with interrupt so far.
            (1). For ESP32 version 1, brown-out reset function doesn't work (see ESP32 errata 3.4).
                  So that we must restart from interrupt.
            (2). For special workflow, the chip needs do more things instead of restarting directly. This part
                 needs to be done in callback function of interrupt.
endmenu

menu "POSIX"
    menu "pthread"
        config PTHREAD_TASK_PRIO_DEFAULT
            int "Default task priority"
            range 0 255
            default 5
            help
                Priority used to create new tasks with default pthread parameters.

        config PTHREAD_TASK_STACK_SIZE_DEFAULT
            int "Default task stack size"
            default 3072
            help
                Stack size used to create new tasks with default pthread parameters.

        config PTHREAD_STACK_MIN
            int "Minimum allowed pthread stack size"
            default 768
            help
                Minimum allowed pthread stack size set in attributes passed to pthread_create

        choice PTHREAD_TASK_CORE_DEFAULT
            bool "Default pthread core affinity"
            default PTHREAD_DEFAULT_CORE_NO_AFFINITY
            depends on !FREERTOS_UNICORE
            help
                The default core to which pthreads are pinned.

            config PTHREAD_DEFAULT_CORE_NO_AFFINITY
                bool "No affinity"
            config PTHREAD_DEFAULT_CORE_0
                bool "Core 0"
            config PTHREAD_DEFAULT_CORE_1
                bool "Core 1"
        endchoice

        config PTHREAD_TASK_CORE_DEFAULT
            int
            default -1 if PTHREAD_DEFAULT_CORE_NO_AFFINITY || FREERTOS_UNICORE
            default 0 if PTHREAD_DEFAULT_CORE_0
            default 1 if PTHREAD_DEFAULT_CORE_1

        config PTHREAD_TASK_NAME_DEFAULT
            string "Default name of pthreads"
            default "pthread"
            help
                The default name of pthreads.
    endmenu
endmenu
